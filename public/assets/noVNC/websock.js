/*
 * Websock: high-performance binary WebSockets
 * Copyright (C) 2011 Joel Martin
 * Licensed under LGPL-3 (see LICENSE.txt)
 *
 * Websock is similar to the standard WebSocket object but Websock
 * enables communication with raw TCP sockets (i.e. the binary stream)
 * via websockify. This is accomplished by base64 encoding the data
 * stream between Websock and websockify.
 *
 * Websock has built-in receive queue buffering; the message event
 * does not contain actual data but is simply a notification that
 * there is new data available. Several rQ* methods are available to
 * read binary data off of the receive queue.
 */
function Websock(){"use strict";function e(){return T}function t(){return x}function i(){return B}function n(e){B=e}function o(){return x.length-B}function s(){return x[B]}function r(){return x[B++]}function a(e){0===B?x.unshift(e):(B-=1,x[B]=e)}function l(){return(x[B++]<<8)+x[B++]}function c(){return(x[B++]<<24)+(x[B++]<<16)+(x[B++]<<8)+x[B++]}function h(e){"undefined"==typeof e&&(e=o());var t=x.slice(B,B+e);return B+=e,t.map(function(e){return String.fromCharCode(e)}).join("")}function u(e){return"undefined"==typeof e&&(e=o()),B+=e,x.slice(B-e,B)}function d(e,t){return t?x.slice(B+e,B+t):x.slice(B+e)}function f(e,t,i){var n=x.length-B;if(t>n){if(i){if(i>B)throw"rQwait cannot backup "+i+" bytes";B-=i}return!0}return!1}function p(){return Base64.encode(T)}function g(e){x=x.concat(Base64.decode(e,0))}function m(){return 0!==F.bufferedAmount&&Util.Debug("bufferedAmount: "+F.bufferedAmount),F.bufferedAmount<D.maxBufferedAmount?(T.length>0&&(F.send(p(T)),T=[]),!0):(Util.Info("Delaying send, bufferedAmount: "+F.bufferedAmount),!1)}function v(e){return T=T.concat(e),m()}function _(e){D.send(e.split("").map(function(e){return e.charCodeAt(0)}))}function b(e){try{g(e.data),o()>0?(I.message(),x.length>k&&(x=x.slice(B),B=0)):Util.Debug("Ignoring empty message")}catch(t){"undefined"!=typeof t.stack?Util.Warn("recv_message, caught exception: "+t.stack):"undefined"!=typeof t.description?Util.Warn("recv_message, caught exception: "+t.description):Util.Warn("recv_message, caught exception:"+t),"undefined"!=typeof t.name?I.error(t.name+": "+t.message):I.error(t)}}function C(e,t){I[e]=t}function y(){x=[],B=0,T=[],F=null}function A(e){y(),F=$?{}:new WebSocket(e,"base64"),F.onmessage=b,F.onopen=function(){Util.Debug(">> WebSock.onopen"),F.protocol&&Util.Info("Server chose sub-protocol: "+F.protocol),I.open(),Util.Debug("<< WebSock.onopen")},F.onclose=function(e){Util.Debug(">> WebSock.onclose"),I.close(e),Util.Debug("<< WebSock.onclose")},F.onerror=function(e){Util.Debug(">> WebSock.onerror: "+e),I.error(e),Util.Debug("<< WebSock.onerror")}}function E(){F&&((F.readyState===WebSocket.OPEN||F.readyState===WebSocket.CONNECTING)&&(Util.Info("Closing WebSocket connection"),F.close()),F.onmessage=function(){})}function w(e){return $=!0,D.send=e,D.close=function(){},b}function S(){return D.maxBufferedAmount=200,D.get_sQ=e,D.get_rQ=t,D.get_rQi=i,D.set_rQi=n,D.rQlen=o,D.rQpeek8=s,D.rQshift8=r,D.rQunshift8=a,D.rQshift16=l,D.rQshift32=c,D.rQshiftStr=h,D.rQshiftBytes=u,D.rQslice=d,D.rQwait=f,D.flush=m,D.send=v,D.send_string=_,D.on=C,D.init=y,D.open=A,D.close=E,D.testMode=w,D}var D={},F=null,x=[],B=0,k=1e4,T=[],I={message:function(){},open:function(){},close:function(){},error:function(){}},$=!1;return S()}window.WebSocket&&!window.WEB_SOCKET_FORCE_FLASH?Websock_native=!0:window.MozWebSocket&&!window.WEB_SOCKET_FORCE_FLASH?(Websock_native=!0,window.WebSocket=window.MozWebSocket):(Websock_native=!1,function(){function e(){return"undefined"!=typeof INCLUDE_URI?INCLUDE_URI:"include/"}var t="<script src='"+e(),i="'></script>",n="";window.WEB_SOCKET_SWF_LOCATION=e()+"web-socket-js/WebSocketMain.swf",Util.Engine.trident&&(Util.Debug("Forcing uncached load of WebSocketMain.swf"),window.WEB_SOCKET_SWF_LOCATION+="?"+Math.random()),n+=t+"web-socket-js/swfobject.js"+i,n+=t+"web-socket-js/web_socket.js"+i,document.write(n)}());